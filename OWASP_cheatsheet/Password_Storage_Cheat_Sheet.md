翻譯自 

https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Password_Storage_Cheat_Sheet.md

----

# 密碼儲存小抄

## 簡介

這份小抄建議您關於儲存認證密碼的正確方法。當密碼被儲存時，必須保護它們免受攻擊者的侵害，即使應用程式或資料庫被入侵。幸運的是，大多數現代語言和框架提供內建功能，以幫助安全地儲存密碼。

然而，一旦攻擊者獲取了儲存的密碼雜湊，他們總是能夠離線暴力破解雜湊。防禦者可以通過選擇盡可能資源密集的雜湊演算法來減緩離線攻擊速度。

總結我們的建議：

- **使用 [Argon2id](#argon2id)，記憶體配置最低為 19 MiB，迭代次數為 2，並且並行度為 1。**
- **如果 [Argon2id](#argon2id) 不可用，使用 [scrypt](#scrypt)，CPU/記憶體成本參數最低為 (2^17)，最小區塊大小為 8 (1024 位元組)，並且並行化參數為 1。**
- **對於使用 [bcrypt](#bcrypt) 的舊系統，使用 10 或更多的工作因子，並且密碼限制為 72 位元組。**
- **如果需要符合 FIPS-140 標準，使用 [PBKDF2](#pbkdf2)，工作因子為 600,000 或更多，並設定內部雜湊函數為 HMAC-SHA-256。**
- **考慮使用 [pepper](#peppering) 以提供額外的深度防禦（雖然單獨使用時，它不提供額外的安全特性）。**

## 背景

### 雜湊 vs 加密

雜湊和加密可以保護敏感資料安全，但在幾乎所有情況下，**密碼應該被雜湊，而不是被加密。**

因為**雜湊是單向函數**（即無法“解密”雜湊並獲取原始明文值），這是進行密碼驗證的最適當方法。即使攻擊者獲取了雜湊密碼，他們也無法使用它來登入受害者的帳戶。

由於**加密是雙向函數**，攻擊者可以從加密資料中檢索原始明文。它可以用於儲存像使用者地址這樣的資料，因為這些資料在使用者的個人資料中以明文顯示。對其地址進行雜湊將導致一團亂。

唯有在必要時才應在密碼中使用加密，例如在必須獲取原始明文密碼的邊緣情況下。如果應用程式需要使用密碼與不支援現代方式以程式方式授權存取的其他系統進行身分驗證，例如 OpenID Connect（OIDC），則可能需要這樣做。在可能的情況下，應使用替代架構以避免以加密形式存儲密碼的需求。

有關加密的進一步指導，請參閱[加密存儲秘訣表](Cryptographic_Storage_Cheat_Sheet.md)。

### 當密碼雜湊可以被破解時

**使用現代雜湊算法存儲的強密碼，並遵循雜湊最佳實踐，對於攻擊者來說應該是幾乎不可能破解的。**  作為應用程式擁有者，選擇現代雜湊算法是您的責任。

然而，在某些情況下，攻擊者可以在某些情況下“破解”雜湊，方法如下：

- 選擇您認為受害者已選擇的密碼（例如 `password1!`）
- 計算雜湊
- 將您計算的雜湊與受害者的雜湊進行比較。如果它們匹配，則您已正確“破解”雜湊，現在知道其密碼的明文值。

通常，攻擊者將使用大量潛在候選密碼列表重複進行此過程，例如：

- 從其他受侵擾網站獲取的密碼列表
- 暴力破解（嘗試每個可能的候選）
- 常見密碼的字典或單詞列表

儘管排列組合的數量可能是巨大的，但使用高速硬體（例如 GPU）和許多可租用的雲服務伺服器時，對攻擊者來說成功進行密碼破解的成本相對較小，尤其是當未遵循雜湊的最佳實踐時。

## 增強密碼存儲的方法

### 加鹽

鹽是一個唯一的、隨機生成的字符串，作為雜湊過程的一部分添加到每個密碼中。由於鹽對每個用戶都是唯一的，攻擊者必須使用相應的鹽逐個破解雜湊，而不是計算一次雜湊並將其與每個存儲的雜湊進行比較。這使得破解大量雜湊變得顯著困難，因為所需的時間與雜湊數量成正比增長。

鹽也可以防止攻擊者使用彩虹表或基於資料庫的查找預先計算雜湊。最後，鹽意味著無法確定兩個使用者是否有相同的密碼，除非破解雜湊，因為不同的鹽將導致不同的雜湊，即使密碼相同。

[現代雜湊演算法](#password-hashing-algorithms) 如Argon2id、bcrypt和PBKDF2會自動對密碼進行鹽化，因此在使用它們時不需要進行額外步驟。

### 加胡椒

[胡椒](https://www.ietf.org/archive/id/draft-ietf-kitten-password-storage-04.html#section-4.2) 可以用來提供額外的保護層，除了鹽化。它可以防止攻擊者在只能訪問資料庫時破解任何雜湊，例如，如果他們利用了SQL注入漏洞或獲取了資料庫的備份。胡椒策略不會以任何方式影響密碼雜湊函數。

例如，一種胡椒策略是像往常一樣對密碼進行雜湊（使用密碼雜湊演算法），然後在將密碼雜湊存儲到資料庫之前對原始密碼雜湊使用HMAC（例如，HMAC-SHA256、HMAC-SHA512，取決於所需的輸出長度），其中胡椒充當HMAC金鑰。

- 胡椒是**存儲密碼之間共享的**，而不像鹽一樣是*唯一的*。 {/examples/}

- 與密碼鹽不同，胡椒**不應存儲在資料庫中**。 {/examples/}

- 胡椒是機密信息，應存儲在"機密保險庫"或HSM（硬體安全模組）中。有關安全存儲機密信息的更多信息，請參見[機密管理速查表](Secrets_Management_Cheat_Sheet.md)。 {/examples/}

- 與任何其他密碼金鑰一樣，應考慮胡椒輪換策略。 {/examples/}

### 使用工作因素 {/examples/}

工作因素是對每個密碼執行的雜湊演算法迭代次數（通常實際上是`2^work`次迭代）。工作因素通常存儲在雜湊輸出中。它使計算雜湊變得更加耗費計算資源，進而降低攻擊者嘗試破解密碼雜湊的速度和/或增加成本。 {/examples/}

當您選擇工作因素時，應在安全性和效能之間取得平衡。雖然較高的工作因素使雜湊更難以被攻擊者破解，但會減慢驗證登入嘗試的過程。如果工作因素過高，應用程式的效能可能會下降，這可能被攻擊者利用來進行拒絕服務攻擊，通過大量的登入嘗試使伺服器的 CPU 耗盡。 {/examples/}

沒有理想的工作因素的黃金法則 - 這將取決於伺服器的效能和應用程式上的使用者數量。確定最佳的工作因素將需要在應用程式使用的特定伺服器上進行實驗。一般來說，計算一個雜湊應該需要少於一秒鐘。 {/examples/}

#### 升級工作因素 {/examples/}

擁有工作因素的一個關鍵優勢是，隨著硬體變得更強大和更便宜，可以隨時間增加它。 {/examples/}

升級工作因素的最常見方法是等到使用者下次進行身份驗證時，然後使用新的工作因素重新對其密碼進行雜湊。不同的雜湊將具有不同的工作因素，如果使用者不再登入應用程式，則可能永遠不會升級雜湊。根據應用程式的情況，可能適合刪除舊的密碼雜湊，並要求使用者在下次需要登入時重設他們的密碼，以避免存儲舊的且不太安全的雜湊。 {/examples/}

## 密碼雜湊演算法 {/examples/}

一些現代的雜湊演算法是專門設計用於安全地存儲密碼。這意味著它們應該是慢的（不像 MD5 和 SHA-1 這樣設計為快速的演算法），您可以通過改變工作因素來改變它們的慢速程度。 {/examples/}

您不需要隱藏應用程式使用的密碼雜湊演算法。如果您使用一個現代的密碼雜湊演算法並配置正確的參數，可以安全地在公開場合聲明使用哪些密碼雜湊演算法，並在[這裡](https://pulse.michalspacek.cz/passwords/storages)列出。 {/examples/}

應考慮的三種雜湊演算法： {/examples/}

### Argon2id {/examples/}

[Argon2](https://en.wikipedia.org/wiki/Argon2) 是 2015 年 [密碼雜湊競賽](https://en.wikipedia.org/wiki/Password_Hashing_Competition) 的冠軍。在三個 Argon2 版本中，使用 Argon2id 變體，因為它提供了一種平衡的方法來抵抗側信道和基於 GPU 的攻擊。 {/examples/}

與其他演算法不同，Argon2id 不是簡單的工作因子，而是有三個可以配置的不同參數：最小記憶體大小的基本最小值 (m)、最小迭代次數 (t) 和平行度 (p)。我們建議以下配置設定： {/examples/}

- m=47104 (46 MiB), t=1, p=1 (不要與 Argon2i 一起使用)
- m=19456 (19 MiB), t=2, p=1 (不要與 Argon2i 一起使用)
- m=12288 (12 MiB), t=3, p=1
- m=9216 (9 MiB), t=4, p=1
- m=7168 (7 MiB), t=5, p=1

這些配置設定提供了相同的防禦水準，唯一的區別是在 CPU 和 RAM 使用之間的權衡。 {/examples/}

### scrypt {/examples/}

[scrypt](http://www.tarsnap.com/scrypt/scrypt.pdf) 是由 [Colin Percival](https://twitter.com/cperciva) 創建的基於密碼的金鑰導出函數。雖然 [Argon2id](#argon2id) 應該是密碼雜湊的最佳選擇，但在前者不可用時應使用 [scrypt](#scrypt)。 {/examples/}

與 [Argon2id](#argon2id) 一樣，scrypt 有三個可以配置的不同參數：最小 CPU/記憶體成本參數 (N)、區塊大小 (r) 和平行度 (p)。使用以下其中一個設定： {/examples/}

- N=2^17 (128 MiB), r=8 (1024 bytes), p=1
- N=2^16 (64 MiB), r=8 (1024 bytes), p=2
- N=2^15 (32 MiB), r=8 (1024 bytes), p=3
- N=2^14 (16 MiB), r=8 (1024 bytes), p=5
- N=2^13 (8 MiB), r=8 (1024 bytes), p=10

這些配置設定提供了相同的防禦水準。唯一的區別是在 CPU 和 RAM 使用之間的權衡。 {/examples/}

### bcrypt {/examples/}

[bcrypt](https://en.wikipedia.org/wiki/bcrypt) 密碼雜湊函數應該是在傳統系統中進行密碼存儲的最佳選擇，或者如果需要 PBKDF2 以達到 FIPS-140 合規性。

工作因子應該盡可能大，以符合驗證伺服器的效能，最低為 10。

#### bcrypt 的輸入限制 {/examples}

bcrypt 在大多數實作中有最大長度限制為 72 個位元組，因此您應該強制執行最大密碼長度為 72 個位元組（如果使用的 bcrypt 實作有更小的限制，則應該是 72 個位元組或更少）。

#### 使用 bcrypt 預先雜湊密碼 {/examples}

另一種方法是使用快速演算法（例如 SHA-256）對使用者提供的密碼進行預先雜湊，然後再使用 bcrypt 對結果進行雜湊（即 `bcrypt(base64(hmac-sha256(data:$password, key:$pepper)), $salt, $cost)`）。這是一種危險（但常見）的做法，**應該避免**，因為在[將 bcrypt 與其他雜湊函式結合使用時](https://blog.ircmaxell.com/2015/03/security-issue-combining-bcrypt-with.html)可能會出現[密碼剝離](https://www.youtube.com/watch?v=OQD3qDYMyYQ)和其他問題。

### PBKDF2 {/examples}

由於[NIST](https://pages.nist.gov/800-63-3/sp800-63b.html#memsecretver)推薦使用[PBKDF2](https://en.wikipedia.org/wiki/PBKDF2)，並且具有 FIPS-140 驗證的實作，因此在需要時應該優先選擇該演算法。

PBKDF2 演算法要求您選擇內部雜湊演算法，例如 HMAC 或各種其他雜湊演算法。HMAC-SHA-256 得到廣泛支持，並且被 NIST 推薦。

PBKDF2 的工作因子是通過迭代次數實現的，應根據所使用的內部雜湊演算法設置不同。

- PBKDF2-HMAC-SHA1：1,300,000 次迭代
- PBKDF2-HMAC-SHA256：600,000 次迭代
- PBKDF2-HMAC-SHA512：210,000 次迭代

### 平行 PBKDF2 {/examples}

- PPBKDF2-SHA512：成本 2
- PPBKDF2-SHA256：成本 5
- PPBKDF2-SHA1：成本 10

這些配置設定在提供的防禦方面是等效的。([根據 RTX 4000 GPU 測試，截至 2022 年 12 月的數字](https://tobtu.com/minimum-password-settings/))

#### PBKDF2 預先雜湊 {/examples}

當 PBKDF2 與 HMAC 一起使用，且密碼長度超過雜湊函式的區塊大小（SHA-256 的區塊大小為 64 個位元組）時，密碼將自動進行預先雜湊。例如，密碼 "This is a password longer than 512 bits which is the block size of SHA-256" 會轉換為十六進位的雜湊值：`fa91498c139805af73f7ba275cca071e78d78675027000c99a9925e2ec92eedd`。

良好的PBKDF2實作在昂貴的迭代雜湊階段之前執行預先雜湊。然而，一些實作在每次迭代中執行轉換，這可能使對長密碼進行雜湊比對短密碼更加昂貴。當使用者提供非常長的密碼時，可能會發生潛在的拒絕服務漏洞，例如2013年[Django](https://www.djangoproject.com/weblog/2013/sep/15/security/)中發表的漏洞。手動預先雜湊可以降低這種風險，但需要在預先雜湊步驟中添加[鹽](#salting)。

## 升級舊雜湊 {/examples}

使用較不安全的雜湊演算法（例如MD5或SHA-1）的舊應用程式可以按照上述描述升級為現代密碼雜湊演算法。當使用者輸入他們的密碼（通常是透過應用程式進行驗證）時，該輸入應使用新演算法重新進行雜湊。防禦者應該使使用者當前的密碼失效並要求他們輸入新密碼，以使他們的舊（較不安全）密碼雜湊對攻擊者不再有用。

然而，這意味著舊（較不安全）密碼雜湊將存儲在資料庫中，直到使用者登入。您可以採取以下兩種方法之一來避免這個困境。

升級方法一：使長時間不活動的使用者的密碼雜湊失效並刪除，並要求他們重設密碼以再次登入。儘管安全，但這種方法並不特別用戶友好。使許多使用者的密碼失效可能會對支援人員造成問題，或者被使用者解讀為遭受入侵的跡象。

升級方法二：將現有的密碼雜湊作為更安全演算法的輸入。例如，如果應用程式最初將密碼存儲為`md5($password)`，則可以輕鬆升級為`bcrypt(md5($password))`。層疊雜湊可避免需要知道原始密碼；但是，這可能使雜湊更容易被破解。這些雜湊應在使用者下次登入時用使用者的密碼的直接雜湊替換。

請記住，一旦選擇了密碼雜湊方法，將來必須升級，因此請確保升級您的雜湊演算法盡可能簡單。在過渡期間，允許使用舊版和新版的雜湊演算法混合。如果使用標準格式將密碼雜湊演算法和工作因子與密碼一起存儲，例如 [模組 PHC 字串格式](https://github.com/P-H-C/phc-string-format/blob/master/phc-sf-spec.md)，混合使用雜湊演算法將更容易。

### 國際字符

您的雜湊函式庫必須能夠接受各種字符，並且應與所有 Unicode 代碼點兼容，以便用戶可以在現代設備上使用所有可用字符範圍 - 尤其是移動鍵盤。他們應該能夠從各種語言中選擇密碼，並包括象形文字。在對用戶輸入進行雜湊之前，不應減少其熵，並且密碼雜湊函式庫需要能夠使用可能包含 NULL 字節的輸入。

